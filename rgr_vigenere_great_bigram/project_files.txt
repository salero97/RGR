=== rgr_vigenere_great_bigram/include/bigram/bigram_cipher_interface.h ===
#ifndef BIGRAM_CIPHER_INTERFACE_H
#define BIGRAM_CIPHER_INTERFACE_H

void runBigramCipher();

#endif

=== rgr_vigenere_great_bigram/include/bigram/bigram_cipher.h ===
#ifndef BIGRAM_CIPHER_H
#define BIGRAM_CIPHER_H

#include <vector>
#include <string>
#include <map>
#include <utility>
#include <cstdint>

class BigramCipher {
private:
    std::vector<std::vector<int>> matrix;
    std::map<int, std::pair<int, int>> positions;
    std::string key;
    
    void createMatrix();
    void permuteMatrix();
    void findPositions();
    std::vector<std::pair<int, int>> makeBigrams(const std::vector<int>& codes);
    
    std::pair<int, int> encryptBigram(int a, int b);
    std::pair<int, int> decryptBigram(int a, int b);
    
public:
    BigramCipher(const std::string& key);
    
    std::vector<int> encrypt(const std::vector<int>& codes);
    std::vector<int> decrypt(const std::vector<int>& codes);
    
    std::vector<uint8_t> encryptBytes(const std::vector<uint8_t>& data);
    std::vector<uint8_t> decryptBytes(const std::vector<uint8_t>& data);
    
    std::string encryptText(const std::string& text);
    std::string decryptText(const std::string& text);
    
    static std::vector<uint8_t> processBytes(const std::vector<uint8_t>& data, const std::string& key, bool encrypt);
    static std::string processText(const std::string& text, const std::string& key, bool encrypt);
};

#endif

=== rgr_vigenere_great_bigram/include/utils.h ===
#ifndef UTILS_H
#define UTILS_H

#include <vector>
#include <string>
#include <initializer_list>
#include <filesystem>
#include <chrono>
#include <map>
#include <utility>

using namespace std;
namespace fs = filesystem;


void clearInputBuffer();
int getChoice(const string& prompt, const initializer_list<int>& options);
int getIntegerInput(const string& prompt, int min, int max);
string getLine(const string& prompt, bool maskInput = false);
bool isDigits(const string& str);
void initLocale();
string generateRandomKey(int length);

vector<unsigned char> readFile(const string& filename);
void writeFile(const string& filename, const vector<unsigned char>& data);
vector<string> getFilesInCurrentDir();
string getFileType(const std::string& filename);
void createLogFile(const string& outputPath, const string& cipherName,
                 const string& operation, const string& key,
                 const string& inputFile, const string& outputFile);

vector<string> getFilesInCurrentDir();
void createLogFile(const string& outputPath, const string& cipherName,
                 const string& operation, const string& key,
                 const string& inputFile, const string& outputFile);


int randomInt(int min, int max);


void printHex(const vector<unsigned char>& data);
void printTextRepresentation(const vector<unsigned char>& data);


vector<unsigned char> hexToBytes(const string& hex);
void saveKeyToFile(const string& filename, const map<pair<unsigned char, unsigned char>, unsigned char>& key);
map<pair<unsigned char, unsigned char>, unsigned char> loadKeyFromFile(const string& filename);
string bytesToHex(const vector<unsigned char>& data);


bool isImageFile(const std::string& filename);
std::string getFileExtension(const std::string& filename);

#endif

=== rgr_vigenere_great_bigram/include/vigenere/vigenere_cipher.h ===
#ifndef VIGENERE_CIPHER_H
#define VIGENERE_CIPHER_H

#include <vector>
#include <string>
#include "utils.h"

inline void validateKey(const std::string& key) {
    if (key.empty()) {
        throw std::invalid_argument("–ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º");
    }
}

std::vector<unsigned char> vigenereEncrypt(const std::vector<unsigned char>& data, const std::string& key);
std::vector<unsigned char> vigenereDecrypt(const std::vector<unsigned char>& data, const std::string& key);
std::string generateVigenereKey(int length);

#endif

=== rgr_vigenere_great_bigram/include/vigenere/vigenere_cipher_interface.h ===
#ifndef VIGENERE_CIPHER_INTERFACE_H
#define VIGENERE_CIPHER_INTERFACE_H

#include <vector>
#include <string>

// –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —à–∏—Ñ—Ä–æ–º –≤–∏–∂–µ–Ω–µ—Ä–∞
void runVigenereCipher();

#endif // VIGENERE_CIPHER_INTERFACE_H


=== rgr_vigenere_great_bigram/include/great/great_cipher.h ===
#ifndef GREAT_CIPHER_H
#define GREAT_CIPHER_H

#include <vector>
#include <string>
#include <map>
#include <cstdint>

class GreatCipher {
private:
    std::map<uint16_t, std::vector<uint8_t>> encryptionTable;
    std::map<uint8_t, std::vector<uint16_t>> decryptionTable;
    std::vector<uint16_t> homophoneSequence;
    uint32_t keySeed;
    
    void createTables();
    uint16_t getNextCode(size_t position);
    
public:
    GreatCipher(uint32_t seed);
    GreatCipher(const std::string& key);
    
    std::vector<uint8_t> encrypt(const std::vector<uint8_t>& data);
    std::vector<uint8_t> decrypt(const std::vector<uint8_t>& data);
    
    std::string encryptText(const std::string& text);
    std::string decryptText(const std::string& text);
    
    static std::vector<uint8_t> processBytes(const std::vector<uint8_t>& data, const std::string& key, bool encrypt);
    static std::string processText(const std::string& text, const std::string& key, bool encrypt);
};

#endif

=== rgr_vigenere_great_bigram/include/great/great_cipher_interface.h ===
#ifndef GREAT_CIPHER_INTERFACE_H
#define GREAT_CIPHER_INTERFACE_H

#include <vector>
#include <string>

void runGreatCipher();

#endif 

=== rgr_vigenere_great_bigram/src/bigram/bigram_cipher_interface.cpp ===
#include "bigram/bigram_cipher_interface.h"
#include "bigram/bigram_cipher.h"
#include "utils.h"
#include <iostream>
#include <sstream>
#include <iomanip>
#include <filesystem>
#include <algorithm>

using namespace std;
namespace fs = filesystem;

void printBigramResult(const vector<uint8_t>& data, bool isEncrypted, bool isFile = false) {
    if (isFile) {
        cout << "–†–µ–∑—É–ª—å—Ç–∞—Ç (–ø–µ—Ä–≤—ã–µ 16 –±–∞–π—Ç –≤ hex): ";
        for (size_t i = 0; i < min(data.size(), static_cast<size_t>(16)); ++i) {
            cout << hex << setw(2) << setfill('0') << static_cast<int>(data[i]) << " ";
        }
        cout << dec << endl;
    } else {
        if (isEncrypted) {
            cout << "–†–µ–∑—É–ª—å—Ç–∞—Ç (hex): ";
            for (uint8_t byte : data) {
                cout << hex << setw(2) << setfill('0') << static_cast<int>(byte) << " ";
            }
            cout << dec << endl << "–¢–µ–∫—Å—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ: ";
            
            string text(data.begin(), data.end());
            for (char c : text) {
                if (c >= 32 && c < 127) {
                    cout << c;
                } else {
                    cout << ".";
                }
            }
            cout << endl;
        } else {
            // –¢–û–õ–¨–ö–û –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
            string resultText(data.begin(), data.end());
            cout << "–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç: " << resultText << endl;
        }
    }
}

void runBigramCipher() {
    try {
        cout << "=== –ë–∏–≥—Ä–∞–º–º–Ω—ã–π —à–∏—Ñ—Ä –¢—Ä–∏—Ç–µ–º–∏—è ===" << endl;
        cout << "–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä —Å –º–∞—Ç—Ä–∏—Ü–µ–π 16x16" << endl;

        bool encrypt = getChoice("–í—ã–±–µ—Ä–∏—Ç–µ:\n1. –®–∏—Ñ—Ä–æ–≤–∞—Ç—å\n2. –î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2}) == 1;

        // –í–í–û–î –ö–õ–Æ–ß–ê
        string key;
        int keyChoice = getChoice("–ö–ª—é—á:\n1. –í–≤–µ—Å—Ç–∏\n2. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2});
        
        if (keyChoice == 2) {
            int length = getIntegerInput("–î–ª–∏–Ω–∞ –∫–ª—é—á–∞ (1-20): ", 1, 20);
            key = generateRandomKey(length);
            cout << "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á: " << key << endl;
        } else {
            key = getLine("–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á: ", false);
            if (key.empty()) {
                cout << "–û—à–∏–±–∫–∞: –ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º" << endl;
                return;
            }
        }

        int sourceChoice = getChoice("–î–∞–Ω–Ω—ã–µ:\n1. –í–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç\n2. –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–æ–º\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2});

        if (sourceChoice == 2) {
            // –§–∞–π–ª–æ–≤–∞—è —Ä–∞–±–æ—Ç–∞
            cout << "\n–§–∞–π–ª—ã –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏:\n";
            vector<string> files = getFilesInCurrentDir();
            for (const auto& file : files) {
                cout << "- " << file << endl;
            }
            cout << endl;

            string inputFile = getLine("–í–≤–µ–¥–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞ –∏–ª–∏ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å: ", false);

            // –ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–ï –î–õ–Ø –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
            if (encrypt && isImageFile(inputFile)) {
                cout << "‚ö†Ô∏è  –í–ù–ò–ú–ê–ù–ò–ï: –í—ã–±—Ä–∞–Ω —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.\n";
                cout << "–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ–ø—Ä–∏–≥–æ–¥–Ω—ã–º –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞.\n";
                int continueChoice = getChoice("–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (1-–î–∞, 2-–ù–µ—Ç): ", {1, 2});
                if (continueChoice != 1) {
                    cout << "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.\n";
                    return;
                }
            }

            string outputPath = getLine("–ö—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç? (–æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä—è–¥–æ–º): ", false);

            vector<unsigned char> inputData = readFile(inputFile);
            vector<uint8_t> inputBytes(inputData.begin(), inputData.end());
            
            vector<uint8_t> outputBytes;
            if (encrypt) {
                outputBytes = BigramCipher::processBytes(inputBytes, key, true);
            } else {
                outputBytes = BigramCipher::processBytes(inputBytes, key, false);
            }

            vector<unsigned char> outputData(outputBytes.begin(), outputBytes.end());

            if (outputPath.empty()) {
                fs::path p = fs::path(inputFile);
                outputPath = p.stem().string() + (encrypt ? "_bigram_enc" : "_bigram_dec") + p.extension().string();
            }

            writeFile(outputPath, outputData);
            cout << "–§–∞–π–ª –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –ø–æ –ø—É—Ç–∏: " << fs::absolute(outputPath) << endl;
            printBigramResult(outputBytes, encrypt, true);
            
            createLogFile(outputPath, "Bigram Cipher (Tritemius)", encrypt ? "cipher" : "decipher", 
                         key, inputFile, outputPath);
        } else {
            // –¢–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥
            if (encrypt) {
                string text = getLine("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç: ", false);
                string result = BigramCipher::processText(text, key, true);
                vector<uint8_t> resultBytes(result.begin(), result.end());
                printBigramResult(resultBytes, true);
            } else {
                string hexInput = getLine("–í–≤–µ–¥–∏—Ç–µ hex: ", false);
                vector<unsigned char> data = hexToBytes(hexInput);
                vector<uint8_t> bytes(data.begin(), data.end());
                vector<uint8_t> resultBytes = BigramCipher::processBytes(bytes, key, false);
                printBigramResult(resultBytes, false);
            }
        }
    } catch (const exception& e) {
        cerr << "–û—à–∏–±–∫–∞: " << e.what() << endl;
    }
    
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

=== rgr_vigenere_great_bigram/src/bigram/bigram_cipher.cpp ===
#include "bigram/bigram_cipher.h"
#include <algorithm>
#include <stdexcept>
#include <cstdint>
#include <functional>
#include <random>
#include <numeric>

using namespace std;

BigramCipher::BigramCipher(const string& key) : key(key) {
    createMatrix();
    permuteMatrix();
    findPositions();
}

void BigramCipher::createMatrix() {
    // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—É—é –º–∞—Ç—Ä–∏—Ü—É 16x16
    matrix.resize(16, vector<int>(16));
    
    int value = 0;
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            matrix[i][j] = value++;
        }
    }
}

void BigramCipher::permuteMatrix() {
    if (key.empty()) return;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–ª—é—á –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
    size_t seed = 0;
    for (char c : key) {
        seed = seed * 31 + static_cast<size_t>(c);
    }
    
    mt19937 generator(seed);
    
    // –°–æ–∑–¥–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫—É –¥–ª—è –≤—Å–µ–π –º–∞—Ç—Ä–∏—Ü—ã
    vector<int> indices(256);
    iota(indices.begin(), indices.end(), 0);
    shuffle(indices.begin(), indices.end(), generator);
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –º–∞—Ç—Ä–∏—Ü—É –≤ —Å–ª—É—á–∞–π–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
    int index = 0;
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            matrix[i][j] = indices[index++];
        }
    }
}

void BigramCipher::findPositions() {
    positions.clear();
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            positions[matrix[i][j]] = make_pair(i, j);
        }
    }
}

vector<pair<int, int>> BigramCipher::makeBigrams(const vector<int>& codes) {
    vector<pair<int, int>> bigrams;
    
    for (size_t i = 0; i < codes.size(); i += 2) {
        int first = codes[i];
        int second;
        
        if (i + 1 < codes.size()) {
            second = codes[i + 1];
            // –ï—Å–ª–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ —Å–∏–º–≤–æ–ª—ã, –¥–æ–±–∞–≤–ª—è–µ–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
            if (first == second) {
                second = 0xFF; // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å–∏–º–≤–æ–ª-—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
                i--; // –û—Ç—Å—Ç—É–ø–∞–µ–º, —á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Å–∏–º–≤–æ–ª
            }
        } else {
            // –ï—Å–ª–∏ –Ω–µ—á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–æ–ª–Ω–∏—Ç–µ–ª—å
            second = 0xFF;
        }
        
        bigrams.push_back(make_pair(first, second));
    }
    
    return bigrams;
}

pair<int, int> BigramCipher::encryptBigram(int a, int b) {
    // –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ –º–∞—Ç—Ä–∏—Ü–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
    if (positions.find(a) == positions.end() || positions.find(b) == positions.end()) {
        return make_pair(a, b);
    }
    
    auto posA = positions[a];
    auto posB = positions[b];
    
    int rowA = posA.first, colA = posA.second;
    int rowB = posB.first, colB = posB.second;
    
    if (rowA == rowB) {
        // –û–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ - —Å–¥–≤–∏–≥–∞–µ–º –≤–ø—Ä–∞–≤–æ
        colA = (colA + 1) % 16;
        colB = (colB + 1) % 16;
    } else if (colA == colB) {
        // –û–¥–∏–Ω —Å—Ç–æ–ª–±–µ—Ü - —Å–¥–≤–∏–≥–∞–µ–º –≤–Ω–∏–∑
        rowA = (rowA + 1) % 16;
        rowB = (rowB + 1) % 16;
    } else {
        // –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ - –º–µ–Ω—è–µ–º —Å—Ç–æ–ª–±—Ü—ã
        swap(colA, colB);
    }
    
    return make_pair(matrix[rowA][colA], matrix[rowB][colB]);
}

pair<int, int> BigramCipher::decryptBigram(int a, int b) {
    if (positions.find(a) == positions.end() || positions.find(b) == positions.end()) {
        return make_pair(a, b);
    }
    
    auto posA = positions[a];
    auto posB = positions[b];
    
    int rowA = posA.first, colA = posA.second;
    int rowB = posB.first, colB = posB.second;
    
    if (rowA == rowB) {
        // –û–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ - —Å–¥–≤–∏–≥–∞–µ–º –≤–ª–µ–≤–æ
        colA = (colA - 1 + 16) % 16;
        colB = (colB - 1 + 16) % 16;
    } else if (colA == colB) {
        // –û–¥–∏–Ω —Å—Ç–æ–ª–±–µ—Ü - —Å–¥–≤–∏–≥–∞–µ–º –≤–≤–µ—Ä—Ö
        rowA = (rowA - 1 + 16) % 16;
        rowB = (rowB - 1 + 16) % 16;
    } else {
        // –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ - –º–µ–Ω—è–µ–º —Å—Ç–æ–ª–±—Ü—ã
        swap(colA, colB);
    }
    
    return make_pair(matrix[rowA][colA], matrix[rowB][colB]);
}

vector<int> BigramCipher::encrypt(const vector<int>& codes) {
    if (codes.empty()) return {};
    
    auto bigrams = makeBigrams(codes);
    vector<int> result;
    
    for (const auto& bigram : bigrams) {
        auto encrypted = encryptBigram(bigram.first, bigram.second);
        result.push_back(encrypted.first);
        result.push_back(encrypted.second);
    }
    
    return result;
}

vector<int> BigramCipher::decrypt(const vector<int>& codes) {
    if (codes.empty() || codes.size() % 2 != 0) return {};
    
    vector<int> result;
    
    for (size_t i = 0; i < codes.size(); i += 2) {
        auto decrypted = decryptBigram(codes[i], codes[i + 1]);
        result.push_back(decrypted.first);
        result.push_back(decrypted.second);
    }
    
    // –£–±–∏—Ä–∞–µ–º –∑–∞–ø–æ–ª–Ω–∏—Ç–µ–ª–∏
    result.erase(remove(result.begin(), result.end(), 0xFF), result.end());
    
    return result;
}

vector<uint8_t> BigramCipher::encryptBytes(const vector<uint8_t>& data) {
    vector<int> codes;
    for (uint8_t byte : data) {
        codes.push_back(static_cast<int>(byte));
    }
    
    vector<int> encryptedCodes = encrypt(codes);
    
    vector<uint8_t> result;
    for (int code : encryptedCodes) {
        result.push_back(static_cast<uint8_t>(code));
    }
    
    return result;
}

vector<uint8_t> BigramCipher::decryptBytes(const vector<uint8_t>& data) {
    vector<int> codes;
    for (uint8_t byte : data) {
        codes.push_back(static_cast<int>(byte));
    }
    
    vector<int> decryptedCodes = decrypt(codes);
    
    vector<uint8_t> result;
    for (int code : decryptedCodes) {
        result.push_back(static_cast<uint8_t>(code));
    }
    
    return result;
}

string BigramCipher::encryptText(const string& text) {
    vector<uint8_t> inputBytes(text.begin(), text.end());
    vector<uint8_t> encryptedBytes = encryptBytes(inputBytes);
    return string(encryptedBytes.begin(), encryptedBytes.end());
}

string BigramCipher::decryptText(const string& text) {
    vector<uint8_t> inputBytes(text.begin(), text.end());
    vector<uint8_t> decryptedBytes = decryptBytes(inputBytes);
    return string(decryptedBytes.begin(), decryptedBytes.end());
}

vector<uint8_t> BigramCipher::processBytes(const vector<uint8_t>& data, const string& key, bool encrypt) {
    BigramCipher cipher(key);
    
    if (encrypt) {
        return cipher.encryptBytes(data);
    } else {
        return cipher.decryptBytes(data);
    }
}

string BigramCipher::processText(const string& text, const string& key, bool encrypt) {
    BigramCipher cipher(key);
    
    if (encrypt) {
        return cipher.encryptText(text);
    } else {
        return cipher.decryptText(text);
    }
}

=== rgr_vigenere_great_bigram/src/vigenere/vigenere_cipher_interface.cpp ===
#include "vigenere/vigenere_cipher_interface.h"
#include "vigenere/vigenere_cipher.h"
#include "utils.h"
#include <iostream>
#include <sstream>
#include <iomanip>
#include <filesystem>
#include <algorithm>
#include <locale>
#include <clocale>

using namespace std;
namespace fs = filesystem;

void printResult(const vector<unsigned char>& data, bool isEncrypted) {
    if (isEncrypted) {
        cout << "–†–µ–∑—É–ª—å—Ç–∞—Ç (hex): ";
        for (unsigned char c : data) {
            cout << hex << setw(2) << setfill('0') << static_cast<int>(c) << " ";
        }
        cout << dec << endl << "–°–∏–º–≤–æ–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ: ";
        
        // –î–ª—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö - —Ç–æ–ª—å–∫–æ ASCII
        for (unsigned char c : data) {
            if (c >= 32 && c < 127) {
                cout << c;
            } else {
                cout << ".";
            }
        }
    } else {
        // –î–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö - –≤—ã–≤–æ–¥–∏–º –∫–∞–∫ —Ç–µ–∫—Å—Ç
        cout << "–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç: ";
        string text(data.begin(), data.end());
        cout << text;
    }
    cout << endl;
}

void runVigenereCipher() {
    setlocale(LC_ALL, "ru_RU.UTF-8");
    locale::global(locale("ru_RU.UTF-8"));

    try {
        cout << "=== –®–∏—Ñ—Ä –í–∏–∂–µ–Ω–µ—Ä–∞ ===" << endl;

        bool encrypt = getChoice("–í—ã–±–µ—Ä–∏—Ç–µ:\n1. –®–∏—Ñ—Ä–æ–≤–∞—Ç—å\n2. –î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2}) == 1;

        string key;
        int keyChoice = getChoice("–ö–ª—é—á:\n1. –í–≤–µ—Å—Ç–∏\n2. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2});
        
        if (keyChoice == 2) {
            int len = getIntegerInput("–î–ª–∏–Ω–∞ –∫–ª—é—á–∞ (–æ—Ç 1 –¥–æ 256): ", 1, 256);
            key = generateVigenereKey(len);
            cout << "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á (hex): ";
            for (unsigned char c : key) {
                cout << hex << setw(2) << setfill('0') << static_cast<int>(c);
            }
            cout << dec << endl;
        } else {
            // –î–û–ë–ê–í–õ–ï–ù–û: –í—ã–±–æ—Ä —Ñ–æ—Ä–º–∞—Ç–∞ –≤–≤–æ–¥–∞ –∫–ª—é—á–∞
            int keyFormat = getChoice("–§–æ—Ä–º–∞—Ç –∫–ª—é—á–∞:\n1. –¢–µ–∫—Å—Ç\n2. Hex\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2});
            
            if (keyFormat == 1) {
                key = getLine("–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á: ", false);
                cout << "–ö–ª—é—á –ø—Ä–∏–Ω—è—Ç –∫–∞–∫ —Ç–µ–∫—Å—Ç" << endl;
            } else {
                string hexKey = getLine("–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –≤ hex: ", false);
                vector<unsigned char> keyBytes = hexToBytes(hexKey);
                key = string(keyBytes.begin(), keyBytes.end());
                cout << "–ö–ª—é—á –ø—Ä–∏–Ω—è—Ç –∫–∞–∫ hex-–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å" << endl;
            }
        }

        int sourceChoice = getChoice("–î–∞–Ω–Ω—ã–µ:\n1. –í–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç\n2. –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–æ–º\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2});

        if (sourceChoice == 1) {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞
            if (encrypt) {
                string text = getLine("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç: ", false);
                vector<unsigned char> inputData(text.begin(), text.end());
                vector<unsigned char> outputData = vigenereEncrypt(inputData, key);
                printResult(outputData, true);
            } else {
                string hexInput = getLine("–í–≤–µ–¥–∏—Ç–µ hex: ", false);
                vector<unsigned char> inputData = hexToBytes(hexInput);
                vector<unsigned char> outputData = vigenereDecrypt(inputData, key);
                printResult(outputData, false);
            }
        } else {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–æ–≤
            cout << "\n–§–∞–π–ª—ã –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏:\n";
            vector<string> files = getFilesInCurrentDir();
            for (const auto& file : files) {
                cout << "- " << file << endl;
            }
            cout << endl;

            string inputFile = getLine("–í–≤–µ–¥–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞ –∏–ª–∏ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å: ", false);

            // –ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–ï –î–õ–Ø –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
            if (encrypt && isImageFile(inputFile)) {
                cout << "‚ö†Ô∏è  –í–ù–ò–ú–ê–ù–ò–ï: –í—ã–±—Ä–∞–Ω —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.\n";
                cout << "–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ–ø—Ä–∏–≥–æ–¥–Ω—ã–º –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞.\n";
                int continueChoice = getChoice("–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (1-–î–∞, 2-–ù–µ—Ç): ", {1, 2});
                if (continueChoice != 1) {
                    cout << "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.\n";
                    return;
                }
            }

            string outputPath = getLine("–ö—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç? (–æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä—è–¥–æ–º): ", false);

            vector<unsigned char> inputData = readFile(inputFile);
            vector<unsigned char> outputData;

            if (encrypt) {
                outputData = vigenereEncrypt(inputData, key);
                
                if (outputPath.empty()) {
                    fs::path p = fs::path(inputFile);
                    outputPath = p.stem().string() + "_encrypted" + p.extension().string();
                }
            } else {
                outputData = vigenereDecrypt(inputData, key);
                
                if (outputPath.empty()) {
                    fs::path p = fs::path(inputFile);
                    outputPath = p.stem().string() + "_decrypted" + p.extension().string();
                }
            }

            writeFile(outputPath, outputData);
            cout << "–§–∞–π–ª –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –ø–æ –ø—É—Ç–∏: " << fs::absolute(outputPath) << endl;

            // –í—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –Ω–∞ —ç–∫—Ä–∞–Ω
            cout << "\n–†–µ–∑—É–ª—å—Ç–∞—Ç (–ø–µ—Ä–≤—ã–µ 16 –±–∞–π—Ç –≤ hex): ";
            for (size_t i = 0; i < min(outputData.size(), static_cast<size_t>(16)); ++i) {
                cout << hex << setw(2) << setfill('0') << static_cast<int>(outputData[i]) << " ";
            }
            cout << dec << endl;

            // –°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–≥-—Ñ–∞–π–ª–∞
            createLogFile(outputPath, "Vigenere", encrypt ? "cipher" : "decipher", 
                         key, inputFile, outputPath);
        }
    } catch (const exception& e) {
        cerr << "–û—à–∏–±–∫–∞: " << e.what() << endl;
    }
    
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

=== rgr_vigenere_great_bigram/src/vigenere/vigenere_cipher.cpp ===
#include "vigenere/vigenere_cipher.h"
#include "utils.h"
#include <stdexcept>
#include <algorithm>

using namespace std;

vector<unsigned char> vigenereEncrypt(const vector<unsigned char>& data, const string& key) {
    validateKey(key);
    if (data.empty()) return {};

    vector<unsigned char> result;
    result.reserve(data.size());
    size_t key_index = 0;

    for (unsigned char c : data) {
        unsigned char k = static_cast<unsigned char>(key[key_index % key.size()]);
        result.push_back((c + k) % 256);
        key_index++;
    }

    return result;
}

vector<unsigned char> vigenereDecrypt(const vector<unsigned char>& data, const string& key) {
    validateKey(key);
    if (data.empty()) return {};

    vector<unsigned char> result;
    result.reserve(data.size());
    size_t key_index = 0;

    for (unsigned char c : data) {
        unsigned char k = static_cast<unsigned char>(key[key_index % key.size()]);
        result.push_back((c - k + 256) % 256);
        key_index++;
    }

    return result;
}

string generateVigenereKey(int length) {
    if (length <= 0 || length > 256) {
        throw invalid_argument("–î–ª–∏–Ω–∞ –∫–ª—é—á–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 1 –¥–æ 256");
    }
    
    string key;
    key.reserve(length);
    
    for (int i = 0; i < length; ++i) {
        key.push_back(static_cast<char>(randomInt(0, 255)));
    }
    
    return key;
}

=== rgr_vigenere_great_bigram/src/great/great_cipher_interface.cpp ===
#include "great/great_cipher_interface.h"
#include "great/great_cipher.h"
#include "utils.h"
#include <iostream>
#include <sstream>
#include <iomanip>
#include <filesystem>
#include <algorithm>

using namespace std;
namespace fs = filesystem;

void printGreatResult(const vector<uint8_t>& data, bool isEncrypted, bool isFile = false) {
    if (isFile) {
        cout << "–†–µ–∑—É–ª—å—Ç–∞—Ç (–ø–µ—Ä–≤—ã–µ 16 –±–∞–π—Ç –≤ hex): ";
        for (size_t i = 0; i < min(data.size(), static_cast<size_t>(16)); ++i) {
            cout << hex << setw(2) << setfill('0') << static_cast<int>(data[i]) << " ";
        }
        cout << dec << endl;
    } else {
        if (isEncrypted) {
            cout << "–†–µ–∑—É–ª—å—Ç–∞—Ç (hex): ";
            for (uint8_t byte : data) {
                cout << hex << setw(2) << setfill('0') << static_cast<int>(byte) << " ";
            }
            cout << dec << endl << "–°–∏–º–≤–æ–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ: ";
            
            string text(data.begin(), data.end());
            for (char c : text) {
                if (c >= 32 && c < 127) {
                    cout << c;
                } else {
                    cout << ".";
                }
            }
            cout << endl;
        } else {
            // –¢–û–õ–¨–ö–û –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
            string resultText(data.begin(), data.end());
            cout << "–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç: " << resultText << endl;
        }
    }
}

void runGreatCipher() {
    try {
        cout << "=== –í–µ–ª–∏–∫–∏–π —à–∏—Ñ—Ä (Louis XIV) ===" << endl;
        cout << "–ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä —Å —Å–∏—Å—Ç–µ–º–æ–π –æ–º–æ—Ñ–æ–Ω–æ–≤" << endl;

        bool encrypt = getChoice("–í—ã–±–µ—Ä–∏—Ç–µ:\n1. –®–∏—Ñ—Ä–æ–≤–∞—Ç—å\n2. –î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2}) == 1;

        // –í–í–û–î –ö–õ–Æ–ß–ê
        string key;
        int keyChoice = getChoice("–ö–ª—é—á:\n1. –í–≤–µ—Å—Ç–∏\n2. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2});
        
        if (keyChoice == 2) {
            int length = getIntegerInput("–î–ª–∏–Ω–∞ –∫–ª—é—á–∞ (1-20): ", 1, 20);
            key = generateRandomKey(length);
            cout << "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á: " << key << endl;
        } else {
            key = getLine("–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á: ", false);
            if (key.empty()) {
                cout << "–û—à–∏–±–∫–∞: –ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º" << endl;
                return;
            }
        }

        int sourceChoice = getChoice("–î–∞–Ω–Ω—ã–µ:\n1. –í–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç\n2. –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–æ–º\n–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2});

        if (sourceChoice == 2) {
            // –§–∞–π–ª–æ–≤–∞—è —Ä–∞–±–æ—Ç–∞
            cout << "\n–§–∞–π–ª—ã –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏:\n";
            vector<string> files = getFilesInCurrentDir();
            for (const auto& file : files) {
                cout << "- " << file << endl;
            }
            cout << endl;

            string inputFile = getLine("–í–≤–µ–¥–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞ –∏–ª–∏ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å: ", false);

            // –ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–ï –î–õ–Ø –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
            if (encrypt && isImageFile(inputFile)) {
                cout << "‚ö†Ô∏è  –í–ù–ò–ú–ê–ù–ò–ï: –í—ã–±—Ä–∞–Ω —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.\n";
                cout << "–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ–ø—Ä–∏–≥–æ–¥–Ω—ã–º –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞.\n";
                int continueChoice = getChoice("–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (1-–î–∞, 2-–ù–µ—Ç): ", {1, 2});
                if (continueChoice != 1) {
                    cout << "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.\n";
                    return;
                }
            }

            string outputPath = getLine("–ö—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç? (–æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä—è–¥–æ–º): ", false);

            vector<unsigned char> inputData = readFile(inputFile);
            vector<uint8_t> inputBytes(inputData.begin(), inputData.end());
            
            vector<uint8_t> outputBytes;
            if (encrypt) {
                outputBytes = GreatCipher::processBytes(inputBytes, key, true);
            } else {
                outputBytes = GreatCipher::processBytes(inputBytes, key, false);
            }

            vector<unsigned char> outputData(outputBytes.begin(), outputBytes.end());

            if (outputPath.empty()) {
                fs::path p = fs::path(inputFile);
                outputPath = p.stem().string() + (encrypt ? "_great_enc" : "_great_dec") + p.extension().string();
            }

            writeFile(outputPath, outputData);
            cout << "–§–∞–π–ª –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –ø–æ –ø—É—Ç–∏: " << fs::absolute(outputPath) << endl;
            printGreatResult(outputBytes, encrypt, true);
            
            createLogFile(outputPath, "Great Cipher (Louis XIV)", encrypt ? "cipher" : "decipher", 
                         key, inputFile, outputPath);
        } else {
            // –¢–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥
            if (encrypt) {
                string text = getLine("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç: ", false);
                string result = GreatCipher::processText(text, key, true);
                vector<uint8_t> resultBytes(result.begin(), result.end());
                printGreatResult(resultBytes, true);
            } else {
                string hexInput = getLine("–í–≤–µ–¥–∏—Ç–µ hex: ", false);
                vector<unsigned char> data = hexToBytes(hexInput);
                vector<uint8_t> bytes(data.begin(), data.end());
                vector<uint8_t> resultBytes = GreatCipher::processBytes(bytes, key, false);
                printGreatResult(resultBytes, false);
            }
        }
    } catch (const exception& e) {
        cerr << "–û—à–∏–±–∫–∞: " << e.what() << endl;
    }
    
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

=== rgr_vigenere_great_bigram/src/great/great_cipher.cpp ===
#include "great/great_cipher.h"
#include "utils.h"
#include <algorithm>
#include <functional>
#include <random>

using namespace std;

// –•–µ—à-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫–∏ –≤ seed
uint32_t stringToSeed(const string& key) {
    hash<string> hasher;
    return static_cast<uint32_t>(hasher(key));
}

GreatCipher::GreatCipher(uint32_t seed) : keySeed(seed) {
    createTables();
}

GreatCipher::GreatCipher(const string& key) : keySeed(stringToSeed(key)) {
    createTables();
}

void GreatCipher::createTables() {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º keySeed –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
    mt19937 generator(keySeed);
    uniform_int_distribution<int> dist(100, 65535);
    
    encryptionTable.clear();
    decryptionTable.clear();
    homophoneSequence.clear();
    
    // –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–ª—é—á–∞
    for (int symbol = 0; symbol < 256; symbol++) {
        vector<uint16_t> codes;
        int numHomophones = 2 + (symbol % 5); // 2-6 –æ–º–æ—Ñ–æ–Ω–æ–≤ –Ω–∞ —Å–∏–º–≤–æ–ª
        
        for (int i = 0; i < numHomophones; i++) {
            uint16_t code = dist(generator);
            codes.push_back(code);
            
            encryptionTable[code].push_back(static_cast<uint8_t>(symbol));
        }
        
        // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∫–æ–¥—ã –¥–ª—è —ç—Ç–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏
        shuffle(codes.begin(), codes.end(), generator);
        decryptionTable[static_cast<uint8_t>(symbol)] = codes;
    }
    
    // –°–æ–∑–¥–∞–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–ª—è –≤—ã–±–æ—Ä–∞ –æ–º–æ—Ñ–æ–Ω–æ–≤
    for (int i = 0; i < 1000; i++) {
        homophoneSequence.push_back(dist(generator));
    }
}

uint16_t GreatCipher::getNextCode(size_t position) {
    return homophoneSequence[position % homophoneSequence.size()];
}

vector<uint8_t> GreatCipher::encrypt(const vector<uint8_t>& data) {
    if (data.empty()) return {};
    
    vector<uint8_t> encrypted;
    
    for (size_t i = 0; i < data.size(); i++) {
        uint8_t symbol = data[i];
        
        if (decryptionTable.find(symbol) != decryptionTable.end()) {
            // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –æ–º–æ—Ñ–æ–Ω –¥–ª—è —ç—Ç–æ–≥–æ —Å–∏–º–≤–æ–ª–∞
            const auto& codes = decryptionTable[symbol];
            size_t index = (i + getNextCode(i)) % codes.size();
            uint16_t code = codes[index];
            
            // –†–∞–∑–±–∏–≤–∞–µ–º 16-–±–∏—Ç–Ω—ã–π –∫–æ–¥ –Ω–∞ 2 –±–∞–π—Ç–∞
            encrypted.push_back(static_cast<uint8_t>(code >> 8));
            encrypted.push_back(static_cast<uint8_t>(code & 0xFF));
        } else {
            // –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª–∞ –Ω–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
            encrypted.push_back(symbol);
            encrypted.push_back(0);
        }
    }
    
    return encrypted;
}

vector<uint8_t> GreatCipher::decrypt(const vector<uint8_t>& data) {
    if (data.empty() || data.size() % 2 != 0) return {};
    
    vector<uint8_t> decrypted;
    
    for (size_t i = 0; i < data.size(); i += 2) {
        uint16_t code = (static_cast<uint16_t>(data[i]) << 8) | data[i + 1];
        
        if (encryptionTable.find(code) != encryptionTable.end()) {
            // –í—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è (–æ–º–æ—Ñ–æ–Ω—ã)
            const auto& symbols = encryptionTable[code];
            decrypted.push_back(symbols[0]);
        } else {
            // –ü—Ä—è–º–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –∫–æ–¥–æ–≤
            decrypted.push_back(data[i]);
        }
    }
    
    return decrypted;
}

string GreatCipher::encryptText(const string& text) {
    vector<uint8_t> inputBytes(text.begin(), text.end());
    vector<uint8_t> encryptedBytes = encrypt(inputBytes);
    return string(encryptedBytes.begin(), encryptedBytes.end());
}

string GreatCipher::decryptText(const string& text) {
    vector<uint8_t> inputBytes(text.begin(), text.end());
    vector<uint8_t> decryptedBytes = decrypt(inputBytes);
    return string(decryptedBytes.begin(), decryptedBytes.end());
}

vector<uint8_t> GreatCipher::processBytes(const vector<uint8_t>& data, const string& key, bool encrypt) {
    GreatCipher cipher(key);
    
    if (encrypt) {
        return cipher.encrypt(data);
    } else {
        return cipher.decrypt(data);
    }
}

string GreatCipher::processText(const string& text, const string& key, bool encrypt) {
    GreatCipher cipher(key);
    
    if (encrypt) {
        return cipher.encryptText(text);
    } else {
        return cipher.decryptText(text);
    }
}

=== rgr_vigenere_great_bigram/src/utils.cpp ===
#include "utils.h"
#include <iostream>
#include <limits>
#include <fstream>
#include <random>
#include <termios.h>
#include <unistd.h>
#include <cctype>
#include <locale>
#include <iomanip>
#include <sstream>
#include <ctime>
#include <algorithm>
#include <codecvt>

using namespace std;

void clearInputBuffer() {
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

int getChoice(const string& prompt, const initializer_list<int>& options) {
    int choice;
    while (true) {
        cout << prompt;
        if (!(cin >> choice)) {
            cout << "–û—à–∏–±–∫–∞: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–≤–æ–¥. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.\n";
            clearInputBuffer();
            continue;
        }

        bool valid = false;
        for (int option : options) {
            if (choice == option) {
                valid = true;
                break;
            }
        }

        if (!valid) {
            cout << "–û—à–∏–±–∫–∞: –ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –≤—ã–±–æ—Ä. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.\n";
            clearInputBuffer();
            continue;
        }

        clearInputBuffer();
        return choice;
    }
}

int getIntegerInput(const string& prompt, int min, int max) {
    int value;
    while (true) {
        cout << prompt;
        if (!(cin >> value)) {
            cout << "–û—à–∏–±–∫–∞: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–≤–æ–¥. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.\n";
            clearInputBuffer();
            continue;
        }

        if (value < min || value > max) {
            cout << "–û—à–∏–±–∫–∞: –ó–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –º–µ–∂–¥—É " << min << " –∏ " << max << "\n";
            clearInputBuffer();
            continue;
        }

        clearInputBuffer();
        return value;
    }
}


string getLine(const string& prompt, bool maskInput) {
    string input;
    cout << prompt;
    cout.flush();

    if (maskInput) {
        termios oldt;
        tcgetattr(STDIN_FILENO, &oldt);
        termios newt = oldt;
        newt.c_lflag &= ~ECHO;

        if (tcsetattr(STDIN_FILENO, TCSANOW, &newt) != 0) {
            cerr << "–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —Ç–µ—Ä–º–∏–Ω–∞–ª. –í–≤–æ–¥ –±—É–¥–µ—Ç –≤–∏–¥–∏–º—ã–º." << endl;
            getline(cin, input);
        } else {
            getline(cin, input);
            tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
            cout << endl;
        }
    } else {
        getline(cin, input);
    }
    return input;
}

bool isDigits(const string& str) {
    for (char c : str) {
        if (!isdigit(static_cast<unsigned char>(c))) {
            return false;
        }
    }
    return !str.empty();
}

void initLocale() {
    setlocale(LC_ALL, "");
    locale::global(locale(""));
    cout.imbue(locale());
}

// ================== –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏ ==================

vector<unsigned char> readFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        throw runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –¥–ª—è —á—Ç–µ–Ω–∏—è: " + filename);
    }

    file.seekg(0, ios::end);
    streamsize size = file.tellg();
    file.seekg(0, ios::beg);

    vector<unsigned char> buffer(size);
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw runtime_error("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: " + filename);
    }
    
    return buffer;
}

void writeFile(const string& filename, const vector<unsigned char>& data) {
    ofstream file(filename, ios::binary);
    if (!file) {
        throw runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –¥–ª—è –∑–∞–ø–∏—Å–∏: " + filename);
    }
    file.write(reinterpret_cast<const char*>(data.data()), data.size());
}

vector<string> getFilesInCurrentDir() {
    vector<string> files;
    try {
        for (const auto& entry : fs::directory_iterator(fs::current_path())) {
            if (entry.is_regular_file()) {
                string filename = entry.path().filename().string();
                if (isImageFile(filename)) {
                    files.push_back(filename + " üñºÔ∏è");
                } else {
                    files.push_back(filename);
                }
            }
        }
    } catch (const exception& e) {
        cerr << "–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: " << e.what() << endl;
    }
    return files;
}

// ================== –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Ñ–∞–π–ª–∞ ==================

bool isImageFile(const std::string& filename) {
    static const vector<string> imageExtensions = {
        ".jpg", ".jpeg", ".png", ".bmp", ".gif", ".tiff", ".tif", 
        ".webp", ".raw", ".ico", ".svg", ".psd"
    };
    
    string ext = getFileExtension(filename);
    transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
    
    return find(imageExtensions.begin(), imageExtensions.end(), ext) != imageExtensions.end();
}

std::string getFileExtension(const std::string& filename) {
    fs::path p(filename);
    return p.extension().string();
}

std::string getFileType(const std::string& filename) {
    if (isImageFile(filename)) {
        return "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ";
    }
    
    string ext = getFileExtension(filename);
    transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤ —Ñ–∞–π–ª–æ–≤
    static const vector<string> textExtensions = {
        ".txt", ".doc", ".docx", ".pdf", ".rtf", ".odt", 
        ".tex", ".md", ".log", ".csv"
    };
    static const vector<string> archiveExtensions = {
        ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", 
        ".xz", ".tgz", ".tbz2"
    };
    static const vector<string> audioExtensions = {
        ".mp3", ".wav", ".flac", ".aac", ".ogg", ".wma", 
        ".m4a", ".opus"
    };
    static const vector<string> videoExtensions = {
        ".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", 
        ".webm", ".m4v", ".3gp"
    };
    static const vector<string> codeExtensions = {
        ".cpp", ".c", ".h", ".hpp", ".java", ".py", ".js", 
        ".html", ".css", ".php", ".xml", ".json"
    };
    static const vector<string> execExtensions = {
        ".exe", ".bin", ".app", ".deb", ".rpm", ".msi"
    };
    
    if (find(textExtensions.begin(), textExtensions.end(), ext) != textExtensions.end()) {
        return "–¢–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª";
    } else if (find(archiveExtensions.begin(), archiveExtensions.end(), ext) != archiveExtensions.end()) {
        return "–ê—Ä—Ö–∏–≤";
    } else if (find(audioExtensions.begin(), audioExtensions.end(), ext) != audioExtensions.end()) {
        return "–ê—É–¥–∏–æ —Ñ–∞–π–ª";
    } else if (find(videoExtensions.begin(), videoExtensions.end(), ext) != videoExtensions.end()) {
        return "–í–∏–¥–µ–æ —Ñ–∞–π–ª";
    } else if (find(codeExtensions.begin(), codeExtensions.end(), ext) != codeExtensions.end()) {
        return "–ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥";
    } else if (find(execExtensions.begin(), execExtensions.end(), ext) != execExtensions.end()) {
        return "–ò—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª";
    } else if (ext.empty()) {
        return "–§–∞–π–ª –±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è";
    } else {
        return "–î—Ä—É–≥–æ–π —Ñ–∞–π–ª";
    }
}

void createLogFile(const string& outputPath, const string& cipherName,
                 const string& operation, const string& key,
                 const string& inputFile, const string& outputFile) {
    try {
        fs::path logPath = fs::path(outputPath).parent_path() / 
                          (fs::path(outputPath).stem().string() + 
                          "_" + operation + "_log.txt");
        
        ofstream log(logPath);
        auto now = chrono::system_clock::now();
        auto now_time = chrono::system_clock::to_time_t(now);
        
        log << "=== –õ–æ–≥ –æ–ø–µ—Ä–∞—Ü–∏–∏ ===" << "\n"
            << "–¢–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏: " << (operation == "cipher" ? "–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ" : "–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ") << "\n"
            << "–ê–ª–≥–æ—Ä–∏—Ç–º: " << cipherName << "\n"
            << "–í—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª: " << inputFile << "\n"
            << "–¢–∏–ø —Ñ–∞–π–ª–∞: " << getFileType(inputFile) << "\n"
            << "–ö–ª—é—á: " << key << "\n"
            << "–í—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª: " << outputFile << "\n"
            << "–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: " << put_time(localtime(&now_time), "%Y-%m-%d %H:%M:%S") << "\n";
    } catch (const exception& e) {
        cerr << "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–≥-—Ñ–∞–π–ª–∞: " << e.what() << endl;
    }
}

// ================== –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª ==================

int randomInt(int min, int max) {
    static random_device rd;
    static mt19937 gen(rd());
    uniform_int_distribution<> distrib(min, max);
    return distrib(gen);
}

string generateRandomKey(int length) {
    const string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    string key;
    
    for (int i = 0; i < length; i++) {
        key += chars[randomInt(0, chars.length() - 1)];
    }
    
    return key;
}

// ================== –í—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ ==================

void printHex(const vector<unsigned char>& data) {
    cout << "–†–µ–∑—É–ª—å—Ç–∞—Ç (hex): ";
    for (unsigned char c : data) {
        cout << hex << setw(2) << setfill('0') << static_cast<int>(c) << " ";
    }
    cout << dec << endl;
}

void printTextRepresentation(const vector<unsigned char>& data) {
    cout << "–°–∏–º–≤–æ–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ: ";
    for (unsigned char c : data) {
        if (isprint(c)) cout << c;
        else cout << ".";
    }
    cout << endl;
}

// ================== –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å hex ==================

vector<unsigned char> hexToBytes(const string& hex) {
    vector<unsigned char> bytes;
    string hexClean = hex;
    
    hexClean.erase(remove_if(hexClean.begin(), hexClean.end(), ::isspace), hexClean.end());
    
    if (hexClean.length() % 2 != 0) {
        throw runtime_error("Hex —Å—Ç—Ä–æ–∫–∞ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å —á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤");
    }

    for (size_t i = 0; i < hexClean.length(); i += 2) {
        string byteString = hexClean.substr(i, 2);
        char* end;
        unsigned long byte = strtoul(byteString.c_str(), &end, 16);
        if (*end != '\0' || byte > 255) {
            throw runtime_error("–ù–µ–≤–µ—Ä–Ω—ã–π hex —Ñ–æ—Ä–º–∞—Ç");
        }
        bytes.push_back(static_cast<unsigned char>(byte));
    }
    
    return bytes;
}

void saveKeyToFile(const string& filename, const map<pair<unsigned char, unsigned char>, unsigned char>& key) {
    ofstream file(filename, ios::binary);
    if (!file) throw runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –¥–ª—è –∑–∞–ø–∏—Å–∏ –∫–ª—é—á–∞");

    for (const auto& entry : key) {
        file.write(reinterpret_cast<const char*>(&entry.first.first), sizeof(unsigned char));
        file.write(reinterpret_cast<const char*>(&entry.first.second), sizeof(unsigned char));
        file.write(reinterpret_cast<const char*>(&entry.second), sizeof(unsigned char));
    }
}

map<pair<unsigned char, unsigned char>, unsigned char> loadKeyFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) throw runtime_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –¥–ª—è —á—Ç–µ–Ω–∏—è –∫–ª—é—á–∞");

    map<pair<unsigned char, unsigned char>, unsigned char> key;
    unsigned char first, second, value;

    while (file.read(reinterpret_cast<char*>(&first), sizeof(unsigned char))) {
        if (!file.read(reinterpret_cast<char*>(&second), sizeof(unsigned char))) break;
        if (!file.read(reinterpret_cast<char*>(&value), sizeof(unsigned char))) break;
        key[make_pair(first, second)] = value;
    }

    return key;
}

string bytesToHex(const vector<unsigned char>& data) {
    ostringstream oss;
    oss << hex << setfill('0');
    for (unsigned char c : data) {
        oss << setw(2) << static_cast<int>(c) << " ";
    }
    return oss.str();
}

=== rgr_vigenere_great_bigram/src/main.cpp ===
#include <iostream>
#include <string>
#include <locale.h>
#include <clocale>
#include "vigenere/vigenere_cipher_interface.h"
#include "great/great_cipher_interface.h"
#include "bigram/bigram_cipher_interface.h"
#include "utils.h"

using namespace std;

void runVigenereWrapper() {
    runVigenereCipher();
}

void runGreatCipherWrapper() {
    runGreatCipher();
}

void runBigramWrapper() {
    runBigramCipher();
}


bool checkPassword() {
    const string correctPassword = "securepass";
    int attempts = 3;

    while (attempts > 0) {
        string input = getLine("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å: ", true);
        if (input == correctPassword) {
            cout << "–î–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à—ë–Ω!\n";
            return true;
        }
        attempts--;
        cout << "–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å. –û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ø—ã—Ç–æ–∫: " << attempts << endl;
    }

    cout << "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω. –ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∞–±–æ—Ç—É.\n";
    return false;
}

int main() {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–∫–∞–ª–∏
    setlocale(LC_ALL, "ru_RU.UTF-8");
    locale::global(locale("ru_RU.UTF-8"));
    cout.imbue(locale("ru_RU.UTF-8"));
    cin.imbue(locale("ru_RU.UTF-8"));
    
    if (!checkPassword()) return 1;

    while (true) {
        int choice = getChoice(
            "–í—ã–±–µ—Ä–∏—Ç–µ —à–∏—Ñ—Ä:\n"
            "1. –®–∏—Ñ—Ä –í–∏–∂–µ–Ω–µ—Ä–∞\n"
            "2. –í–µ–ª–∏–∫–∏–π —à–∏—Ñ—Ä\n"
            "3. –ë–∏–≥—Ä–∞–º–º–Ω—ã–π —à–∏—Ñ—Ä\n"
            "4. –í—ã—Ö–æ–¥\n"
            "–í–∞—à –≤—ã–±–æ—Ä: ", {1, 2, 3, 4}
        );

        if (choice == 4) break;

        try {
            switch (choice) {
                case 1: runVigenereCipher(); break;
                case 2: runGreatCipher(); break;
                case 3: runBigramCipher(); break;
            }
        } catch (const exception& e) {
            cerr << "–û—à–∏–±–∫–∞: " << e.what() << endl;
        }
        
        cout << "\n–ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è...";
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }

    return 0;
}

